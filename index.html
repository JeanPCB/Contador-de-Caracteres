<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>PÁGINA PROTEGIDA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">PÁGINA PROTEGIDA</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Senha"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Lembrar deste dispositivo
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="ENTRAR"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"14eb387c226daa4572ff69cc8df20813c9fa333af36230e54fb364b0d55d3897ea802be2def31635ec696e06955c005cf1a1d9b058ca00d604fb88c2968bf1a03d48ac05265a3ff1ce02fb0f1e351457694e94769f22a8e76ddb1560d446cdd7c64522049f84161daf5d84dd6b790f09933c8109742d9d4c207cdb56cb1f7cfc37b11d2396c4b8237e1d0c303af60be66ab0744535f7171e847ad6b82a4063edc8727ce04014590c2f76f47b147f989c4772e6aa408a4a4e81cfb1f8b61f579f8f4b585c6124e0e04cf08908d9f10d9658e8da147abd4108a3d84ee3dffc103b85df58db114a9d03caa7e957cb0ed22ca3738783d3e79f63a9e7b5d1afd4a8db8d311085da1f97536d542fe16c45f7a1ad99f93193052bea2719b6d381486d648e66ba18e5449a940fba8be098834b5ab045b3c68b551f675f3a932342c280f9e6bd2e763aee8bedd959a99f5e15958bc068831626ccfc82d93a48d2b1d9bfb19a47ed94fe0945fb9b64493a65e77d4b2a0841ec306b83fc0abe26a8a381c20731bfa4b5b6fd7bce711de092cba8c9791e79f39acd55009f886a7611b01ec2eb98974f95b70d176f68cf63851f4ff4161e475d32a5d8bc480ebbad18229619f0635615ad32bd5f52acbc9821c63d6036806c389fecaba76bb1dec19537d2d566167cfd9dfb4664641d4177a3b90dab2712cd430bcb328c94009690254c00f928f9df8744a9ecf84a7a02b3344d5061f661be90ca21056cac3839df8c2aac9b031603a000a0a763e58d3071d2aff87e2b0d3ef28b43c2f237186e7b142733ad2b8d9bd4a1e6aa85549b75a896286cfa27d398d76516b9793a45d17f215ff5a555338dffe11f477b02528cebf1429f45f3b775d81616d0f46477c3ea854eda72d37c3db55d7edca5e2efe98c8b986a11cb4ee16391319a998f3a44abc0fd1577c344d2848bb59c27cd27cdbf11d229ea79c2d4a2153366bde5611bba722d867d4a5c72f3eb5fd1ade7d80f9085b467f75e70412f1ecaba46482c847faa2e50683e55d03ba5407acd48ee96e773da9e3e0d7853f6cb532c6748daebfbf56ea4b5405f0fa21a3714202237dfb6317d502f7132f0633c3e6628e71a7166c72ad7be201e3a49a6ea2b422421a4e23742b9296b50d9a37e7c898fded7710fe03db44bb677e7a49693b213f913a1f033a12a32ba2328467dc949f93f3e9791f071df4e0275e96f17af9de4606bd29f3176472e8a844aea3e640868d118255e58583ec8f5bdaa5e7d8fa98874df0e52e43a8279c43b7bfa3e935a93f9462af755d500de42a4ebb808077b4bcb4083d93ae4c6f59bf7be31751876200371148b99936024d3ad10d1e707e74302950e352896ef351d6a65785a0c2864f1f7f0bb86a86d9a139ba24cb8048293fbe36adc68d0b3dddf88201828a9993b094f4cf2d99cfde353c9d2968023815b3484de924572c0f6697bbea34b17271345391b89e674e8279e02df4d36e2b736af0aa95c5fa3cf559582c669dba79c14fcbbd21218795ea59df15c45af1b436999ec55b82d4e1e4f5b184868fca138f0ba39bf26af027c3397c1cc24276d36fd93d5474a440de6209dc343fb99300b37e54eab8366e8dc3fd26e91edff97a05f8d0abad1c6d2fc5975ababadd6e347fac98f3599a88a6f0bde6b60bb99a6d3192d9983cb895d8affa85bfaf58ad8e07b86c302bbc5af1f3f55303f22ad15d8aaf55a7686f7c2367e6a8c396a627ae33a306c217aeceb160db358d49c17fe944e2a6c89400cc26657c63016817991359244052a00a8b9528569674558ef6e55a2bfcbc3b74637a851fa0ba98805319dda0f1c8df4624928822544415fedfca8e8592edd964d23fc483040f480533565e7a3433c764ed6373495f6cbc036c0476fe32b02a362ae713d95a2a6ebbbfcc820a3ebbc580320222356f656cb63ed496c7f242088c989d8c810b5b24da8a0004c078ab0f9aca8de8927b691d37f3c751d7ee7761ac435a378a1ae4144047dd3c964f1b6ca960b0d53d236bbf4a8c075bb8ba283cce40be2f55fc993ca1a28909822b9bfa15f504bf7c122af7dcb106ec413805d26c42937ab02bcc52e13a1ab428b9c35914fb5055ef7226a8bd2ced519aab908f847a3555c9db265ffbcabfd9a23150595bc1fb940e7c0700cf8c609a0f7d7878b22e727184586fcc4ae9ac3acee6024bc779c0d26392f69a21aa186b3a90b51466cb467f79b4c2790824a2fe51b9fd8b465ef39926c68404a72e835bb53b189675f959fb34aa75721f6a87a41fd49c7085762e21d9648b3b56ce2da7ee6138363a19023b7defce298184ad3bd3933408b48cc5934bb3dcdf86c990979527aa8296244758a111d77a393bfbcf55f6ccdbcda690afb49eda51e1de84909402da144b4394fefcd98d86568d323144352fc364fad95b25aef787fa3b3d0bbc00b67852ee939449300ef1bed1811dabdc1aa0f460ffaad70f10d91d63834e45ce5db5ac2bdb11ffc4ba71a45def8b858be923600eb68496935e2b0698548d3b34ea17e28c056b2dbca1052c4290c47e672992e47a9ef735a5563b80e16337b246116503dd84dc343a91c5caeff4117d5de40aecdf30a4506c2a57acf93fb0d652640594df801d81f3cec8e9ad514ce3c1aa60c0f2f769a87737af73c37d78a44ed73168135e5269161f4bcee38095a5896a63a3846dd2a9c96acffa8353fd5876a2bb18bc140092bb40b94df58cc9f7a74df4307918631c6d722ec4770620f65e831db2396f1e7d93950cab72b4adbae3714c7a70760c5d3cde7394a2a89b6dcac583c830f44dbf9ad3c706c824c5a40f5550eb81e5ad5dd34547bb1f9919c6f04e063784d0246c4b0123f1f4ae9d9d3251dbbb2f8328bfb6709f08c3be3d7497ac3743631a59d83f95179bb5b39b891bd7482d5b97e41dd33a0973ea7f3987743f6f61266ecc89053d3fc68c424cdc537b29d868164298f5639a0a4bdf6d48c8def27d8eb99947c4ae8a4666f151bbf804e6017b8d07da0ddab4c6bcba169e98f4af23fabeab55100afd5f07cecd553a829da84c10e241e77e7a146c6669a3ca610c2526b404145bf0876fe6f7850595aeb173403e82562d4578da3a2b2d4c3cc34fd70fb915f03bda2b9ea45c6abd2d38bb17167fa11daaa377523bc9bc93b44e8c0b4ab769f2136082a0cb413f29550a4e56c6ef123cbff40dbbea875a6d00caf07675a650e7deee9ad1521e1e516de2cc6451cf59663cabcdcefd1d3c3d2e285e55e95b55e03531c9db611ae02de5834d45e85e5e769275a5c0c9bd1d9009be78ec7e0fccc5c276ddb0ba3a54484d57fc2710e8c8d1a603d8d6aabace6bc83391d61b4118b3074fe7927e24cd3033d7169c9df4192fc42007d0dfac9672eb6ebd1879f4da9b940b6c11e18cea0bead56a8652f4ae178c20ec151e6fa6e49f79fd8413e1bd2a415d2f02bd5d272862ae2b9fc147d82c3ced5c30276f592a65264393a16d2c1b9cb1dfd2bb1b0e74783132a5b78f75048d395e20efaaf913aeabcf3538a8ae24987c62b082c58dc91b0196c2466c2c52eaff88bd28c5954c93dd4983fd2a1472a75000bc44ae3af5b6ec61b9d2ef9d83a2af5afc320d77aca2912ab73c7cf1fac687037ce77c29fdfe48add58c44838192600ba42701f694681f3ff954ed54c2b06c7b3f670453be7c41aca7852085f77dc29c552d813f373867707a7cd264419b4a0560a39ad6df952ff545ed6c664fab72b84b96a7b3cca9f2d7ec5ebeb978e603248ff522065b9ef26c753f080edb0eeed5766b2f7f27367b414e1e406b4f59f1723d672d571154159f7a84f09f72998cf1908da28126f015d218d5adc22d23b76ee93ce367e92136c4a5a72915d6e2edaa88c08dbf25703691c4b126ab1924757dcbf7bf9a91914f21b35b3581c0c246370a61f2dd3a2c8c10f9fe3013c288d83ef65616755ded86347c7e1535c65e22d2250b13df55e1c42a41a822634154854bf341932091c9a054f2f07625be429f117a2921d89e7141593f45c91540fb94a73db60793091822badd6fb01afd8fba6c70eed977ced56f7aadccc3d4043a348915fce194a125e8bbc5340f1357f09a17a591ab3f6775921e2dc93a91a7b194fd6ab2949b502336cd8a8b02a628550c3b75df03f6621f16e290a928297a46b1b6ed5c5e620a4f2bd33987d75c04e48dad3948453f0d2174784436b7cc93b0b62ddf96bb4df861597682eb587eaebd49b8c315411d2c225ab3460887b97fa75305e14c385f992c537308e01e989a9f593c7329dd47ee9677661948ba1946655bcd0d2ea33a4a45aa0a4c80399aab09c503300c0fe34bab033ffa0380ecd49fd40e11e8ddf0fdce4824a838717d22fef22e48968911bf9160cd6c0cc7c9c68d18dcda91381b7e5795783b6b915802c6849731202909b4d7d0b68c7cc516fecb5c78701840a84c2c7f8c0ec6dd1b379c1fe7011b6f83973c75f9e62d03103752ec611ac8e049ace581e787141de54b411587ab0582fc8fa3bccc2df55a053b765c014c2220639f9b9806b1d9296714bdb100eeab3ee6abba5f5e9962215668ce9c329ca670a673efc6e617cc13f347aa90fdcc5e919bd4d5798bdcbf8559da362b289ddce08a0cfd79178f14b6d99d7ae6d5fdfb3d928ae38fc1cdecde75bf2195fb324bf717adb30629c7a2ba702659523bcfe3bdf6555cc632ab946615467550cf281ac1745e4132968d3e9231c23edbd514dd272bd25c54630521ca4c5d932fac141d1c2ec7e91226d1c9b3819ea418600c8f85927be983f3144007dedcd29c0ef9258ba236de788ed999e82ceca6b9b792964f5660eecc12d9ee32a139c5d76f16c80aea8e572168c52df6963d09d8b12b4de9774fa1bd2eb168536d490df5e6418baeca2a55aa0ee35f6d37ffb62c7f6e828e7c6efad4e37f10efdd6eee6ac270d71346d02dd27cb804237f6a531fff20d2bba1ac3adc470c705a95415499d32b69c4b0942fc85b31dc27a649304aec2bbea85b53aa76fddbe32035d0fbaae3bed7ebbb705793867cf6fc3528fc3a9a1fb3aa22c624fb766025c5a8b80cc9eade50f5f8d6adde1e732a1c859b30c6c62bdcc0f10bacb1ad3d646d87779140561d01cf80ae3fc5f5c0439f1b6b51ca919fe506189b95534575a7ddcb300a33b717409cf06662cb2c154aad40ff1ace3f71b0c70c5308ad6218f54acad07f25b86e1e0969c206b157dd1aa005668371d19043a3630e9b17dbc98e52f9864dae755ecd5d279eb6e4dc4baca8f0fb0916fb5369ce46af112cb39bc052633a8b210b7a88c6a3652d33258872c6944859ea39d0aede0c63e913bfba713d0f1c628a581207cbc5edf72f9e7959fe097cdd43479dbe628883f9eb92bcb59f8999e79d4132df9d62b3503cf04491740a86986ccca3281634240316229a14c66290ac3c928e1a50a8f6abcfe197a09d5a4548c89b83e1f34e0d08c821e42cf4415368f91f9b74853f7ba679a2f7c9b8b3de9b73f978de96f738f365fc5646b1f0acd209cbf5eca4a6260192180bd503d475cfaf76adadedeec5b49599ccee32248c70258584c0f0a77931d9bf0524cfbcb6334bd1fc03ccc735f60670f05ba9fa77cae94294fab21b5c22ecfe2fc37449cf5ef3ccae59fb6355bb0bc7ee6b76dfa84b4f54478f4de4b0da16b9d17d02d56c7a37e8b46c913df5a4014d3746e6f3021927d494652582c62f401ab97af4b5ba65c03d48f6fcea8649289ad035d28265175c0c99885e86c9d43d296e3d24684c59a898d46d15cc4f8336d521ff5272a085530c3c9a6f15a49b8a868b5813b4cbb6bab6b128d6b9d800a06a3ab713092855c64494aa3c4e980991a6c1de04dbedcad9afa1330311655ce808554f49e9ba25f3eef6e1e9c5babe30d4a0734eb00420b1a9d058acc3ba830cf5bc0e9b989c3922913f1efd9e2f9369635bae4f7734127d9f893c0594b0440bd176987e15f34258fa8150ab254604fa6d23207fbc09d4388cd38b7a4ce139f3f9e6c3bc80e550dd8875bbb49221754763f8387e09af7dce4859e295d1d9d7c6707e6e720f630f14fd26aff00dd216bac7ce32c92f6669463e356664636bf3ffb47bd21b0358f41048d3ee388ff68c5b9dba49fa1ff7de41da0b95844a6d470ab64654f60294e1082929ee1ac466c33f909d043f25bde82e64f24a580dd9ee2115d49a8ff3f86397311ccbd38ecafe249313fd05cfb327fb49d3c7f6e4e5b2316c610d0bd2020a026e749960cacce7ecca42e3962196aaf6f627e4d759c8613fdd201427838367e952d5cae93081c6b27c66749b7d9c945e94f8df4cb9fbbe3429da90baeb7d2d186252c632b29d8566753787b88a285675b9ccd0ef7078af0b96c682b1609e5cb02ca5d74d5e688bf743ec8f11bc011616262803a620a43792e17cb39dc02eeb646b7b6bdec9823ea835f077de6e4825c7a5d5a3876e3eaec1abbd7525d1248c1d7293743db9b6c055d037176aaf112463747dd17102a6c3d252cd4547bdef94df60f09b885da9e8791487e39ea655855351e0e70f4aca5a642ef65f39959ec22db6e6e4dbbe5122fef551a889e8ccb8bfb585228aadbdf67bc1ea957fadad73c7ef64d06737b61c76e6a9f780174422b1d3dde07966a24340287d0933eec575d84bf9d8c5a6f3cd945cf858ea31744e372b7670b145cbb416cb28a91df77047107587b4fee4e64d0da76c027aa322656d6564069649dfc505346fd5d0c51f15d7e93854349eec27e05c20e5e4862b0f1ccd691dd8851c235a8dd971ab4239a67c817cf4a838eb99d301b11eb3bce418faec894d44564b2d4ab50485e0dda9a2a08e7d1569a59fa7f0f633469ca52a28bef1029192bbd4445355353a54f3acfc1bce1a40dcd8e5f502b6d9f368f90bac9c11aabdfe7e3548ff4718ae3cade57b5e4c35217690acd80fdbbc486288f72c520a6484335c38f5687c068d3974c5ac04ed3000e5a8c1457c3f66208a3f6f9607e45047dd01b5af321c97cd6296a455b72c8292e4e476782e04bb9be1db51e97d85682951c4235fbefe43a31493b3c602ff56357b421034c6584cc168266b920cdf1c0573fc32bd6c27f31a6117789ef281d5072c9be6cbf770b9ba2724f88cf130dc137dc0033ff2b9fc96fdfb77c511f356bf0422217204ca85d0bd8b7774c84db5bae55096f23c1465086199b181a2b34e6ea726e390d867af2a42891999ad6b6044f479eb6cf5000ef75759ce1c2d2aaa69dc8d133f71fc66c65a98d321fcf6c496570e20c139b59822e5be7409692c0e5345349580a030f339642b0f53b8d8e22cbf7b872a990f9d4efe24558b876afa1f13895877d5cb592090e6b63db61cfcdde496ec3c826418887db0d24bf948e8468a51bf78afb428fb789044dfb391e71d315c3c04c6b99c144e2bd7919542aafd56acc4ea3acb1dd44a026965b35de366906a7c0b5429c71892ff591cdb573159a3960bdf2ab52e02e10fe204dc94b70ab5f3928ad8ea8a6b6b19f63176431c82df68d555f01b38a3fe49bcd481262c0ed9cd78cff322e35bdbde762a4a8d6715b492bfcde163ade5f21a85f02cd1608c6ade6b248bd5a709912ae3493b8bcbb45979a7f58e563d58b7a2f8fbdecc5fc9ef0491fdac3e24200405ea879be5f20708d47bfe45f0d94e09ba7efbcf9956f62961306d2533edc48e7686c2987b30c45325d5dd9c5d65aefe5f1046e3a1943b3ff17141d7528015c1ea0b67615084c03da419a362d0e1f39c0b92849451b97dc6f08aa1d9c2dd51ee7b7d18af57b97b08d08e89493fa55b5fed66d4b6e3908e7677e4a00c7bddb74e5121cc356d776e0823568fef8970432dbe97e1c8f5959bd158916e57840e5b10aa65f6c26a28d85e6e20a70ed193adbb3eb57e808d4aff16ad92d4889ad4f04de9e6c6566e0cbc4eaf3a103221ea897fdb847c6612881316049d2e29ac58baa66113b0cbc6b9aff986d720a513aa53a438d57e9479935e2843fd079a0622cb546bdd7bb763ffa2e14111d022712d5041906372b3346330a3c1650f28f4f4effc64b83ada89f0827ec27369818ebf8dbb099cbf6d1b9bfabeffefbd28b4efd27de9cfb5179db8e09a45aa89e574bd75fee9878595ba1c3fc83336f3f1e448df819b61be3ad09c79f846cf8daf0032719ca233a2f7453e0b50e71fcb1eb64a63502dba788b59bd0b9ab7cbb6f50deafb9b8c6c92a4aef37b46764b3731b6a7b032343e421b6faef608274026a15e611e8093aa236231e5ae70ffb08f4d91b67d6285518ef780729c4264fcc74ea9c2299e6c46dd2b3183cb201ed7aa4d666440dbf328651abaded0457e23cbd3f3f771d04494ab58a0dcb5c1dea1fc025d286d2599cb7df33f186aef7d0765108ee262470b250a87149d6dd035bc74f04a5c40a613ee8018828cc453a83f695234b852f966356152a50375d2f999c718a0d13420a9e0ae85a4e7699fb8736f08a518aca96eefda3401e1b569ee2327572af8b965289f767a4a3f223683abca543549bd4858c5392a67b344ebfaa031d13466723598eab12e338018357de7b91dc37aa2c09c0cb38dfc4a86241c525fc58e5f4a6464ade02744ce39743997f286a700bbe17c008c92e1cf50d886b30a59ea86956e5b07a811aa2ef83a2afb603df24278ebde4c84f9e8696b046503f887d29c28272973b54591833fee736800f7b4faa02a6076b26cb6f0842d1230dd8e29efcece2811ef86c733fd2c47152390ecc8266542e4d6b6011ce9b1f8c5e61337b8067400937daea20595cbac640dace55132d741664150d6a5c0cf95752ba3f9f76831df4ba33f8182bf14bdad32f6b9048453386b36165badff5e4e39fcfea3d04d8819cf9219c6c473fcc416854feabc2f212ebb8401a5c5467ed7b3075dc27da452381562b4e7199ebefcf7bd7a837777900cb5a87a4bc5d10339c3df3220ef29cbaa1f0a54c315aa37507c9896fccfeba17ef3f9aed090c1f98d34fa15a79986cca7edef710540cf3dc173bf2daafe57a7c3c76d20e2a1084d83c8415f02ea2feb57cb57540dcae352cefcbe76f524db8bea418a220c9bd65abe15af33ebc3f0bd37bd4b548084dc7de3ae8fdc8fefdd992e41e00e907e4d285bcc5fa935d98e88858db077c6e772817212af7669a4977280222c9b4b00089bc0ede168e247030c3baa8f8edf28227fa389689d40f3f557a1c52338c48213c0d3bbc8b1018930e48d75012e98eab5072ab74383ac91f890af0c9cc37685de1bbbfa8d6e383acf9cccd93cc18ccc7674fe70bf5d3d750de52a67b5ccc5d97ac84255654b4c045a5c49cd8319af3ded592c204626fd4c07d16f197a69c2df488628d501978bde2c068dac9fdc0f8fe71afa1c42e0f9456a7a4c102caf61774f6facbcaaf39479c846c4bb74212f77876066ea7f5f77194053c4325660f58e3b7a03119f86cf32a50a4f7a9bac76592d533e35b59ea4015ceac12674444e368e7222508ecc5618233bbe08565837d7bee9d2153fb0519ad3c852e55e7e0149589db75a7ed9a2064e90cd86121a90ed19de21d2d3c8987751bfb65a05c26717a76ca5c89522452d691f616ed22d291cdd3d4befd4bce77876310e0d3c350f18242caf27b3aecb3408fe45b76b000c18042ecc67785b82609ec9cd432ec53695f831f1e15854b6a35284b12223c0525583cddec56cdd4966c3bfd46526f40b74ccc043a6d25230fd5730831c4a97de26530b4de51a7e665af58b8c5573d9279c7fe518b0f98e00f5800bbd67b235c5a9f52ea407eaffb027339b21e6f02c30c0a6bb8601891560b56b9f321292661adc706e29eba9f341158c5476c09aaa5263e056f23110f01820ed35425056ccf71172f43e9d2429427a3a2d459e3be94ffc99ccb9fc71a737bb7239fe2c54b81cf58ad6d7b1b901f143a2700ddeaba14c010364cb3de3cd98bb8994b304978997914639e9837385fe351378e3a3e9f88b820827083da0f74d5a905277332c4080b713f30e4283a029be6e1729cf9a8c8966a8104670e570d875aeb7e8761163d9cd11617be7f3202cee6fa49017067e69315d3480cc8df6e2a92e0b9cc69fc77c4b4d5e852998a9b9b13329c9df94f6d184456922954889a9af6415f7b8493359493bd82253d094f6d73710cfb83f8734fd225270887b221bdb29497eb224d87d215f96d9d4b0136e0b35687756f7ae69e36a9822512f7bad9557320aa770a7c632a3a0eef4740013e6e127752fd6e0913c6625ad74082161ad6ec0bac975f06d97376b518db1daa175e98fa3225dfad100f936ce55a8eea90eb41b0e3eee6321dc37bfafd233c3b2ea64dccd4aad4aeba14ee00815c8565e314d4596ac453269b1f4c2a6d4287d5870ab6ea1d870e191be40d094479184a43ca9c9430c3ee5073ba7188a61a09452c5cfbbe7766783c4e2e4aac551250145c3be6e71b370cfc64cece39fa450cdb01fedb673cc6f0fad282e3b8ef5d9eb32d90bdd336d233dd61cc1d5068767c07c9463322334e955907e9df4558b78eaa30fbfebee83011902ed4173599626b3a555cfd6d93baa9dbca6f42a367601f36dfd3e27d9c6324df0acd2882e009e8c0ff95f548714c733043d8f1c59bad70d014118d278a6883a971b407958d0573e1b7ec7b1e77e664246e5c3f288ccfd9435b17ad9dab5f4e3cb5971128df925834ad2c0f9b3a03006403d9fa5030563920069bbe6e3caae78f5b69d29992840a1f6f3155f9b1f70bdd5a538fc8de251991db7d5694047fc7b717f8ba99cd9bf6d20c5388f6e845e07a335f542bdcd62d08b713aed59b4bf3a21f1ee580c1410be7976974a676f5410d57a004f641df6f4adc41fb06988a8d1e94dddceeefb211fc8c0536101ff1cdb34fbf4d2238aab0a1a87ebbcbf46f8d844f42ae24c923907edd0b1c282d7a8bd2be4a9c486af18a9dd782dbe1bf4e5e8ca49e2a2b6996e6886b9c62bf3fbc659cdee6aa14f042d9707a164282263f2da0016fdc13f0ee5f42ad93cbdf061698e56fbbe5fb8a3b556f78d45750c4a81a781e2298ecfa588aaed44aca4229b429941d44c42ab4087494318aff06b83481872d9738156fad2c238d15325012dd4dceca52a9fb961a4593cf57125eedf3ae3fcb3561f112f3dddf86c0783b01942a9a4b9ff9ca2cb5429c3ed554ddea4eddc8015676bd6097285213e939d5acb93aeb4cd0adc312b70671290917e8b180d35425966cab5838b76e185e64b83d136547feebeb3dc366ac5ece249dfea3b2d961f4a605752158ff64e3aaa86260569aff57c1cbfb2e2aaaf3ed0c4380fcc129c70e9606f42370f46b62573ca6d9f107bd7239b776cd4630f5f0edbde99e3452c1776c0a0dfb5b809d587a29f14e489bca12a344c0344b566fc912d79c2d921071ce2b7ba7f9c2674cc6844d284a4e279ad2e3e861b25027d3da6f0d1de244b2d61b42fa5577b8988eda021d3af421fdc7c57c1b3e81f51b55fe93526f7a88b124ba191cdaeae40baa7e1ffaf882080ae0bf0e0a1b5d2a6e9219eac1999fb3901bfa50d80b986471a7e974e15ac1a892726c148b886964262561b70afd94f27df308f5054c2eb9965fd7be44300dad3e1c4c17449dcc90eb95414136f1d51c2a1df8418985512815adda1152169b600a307bab8e1ea43ce416cb2e917e12b32a109801e357d1522d7e0c69cdbd05db00d33f2fbba614cd9220c60aea1154561e410a2f78189bd2a4c4087704b00a4977317947aa4ae55e5d55542376b2e5b3d50579dbdb86f458e5ccab16dbf66af6d3103b42077007073addcf9878d5985f28d8c953d5a96d60bfcce4707b9f61bc94a57e841779d930a0e66fbfc2e9113d8bebc5b64929bb44a7d029d3ce679748b990487b88b864c051fd44f13df772b226786b93f411af6b6e6693b6df4b1241eb5abbfee14842ea8e97f81c873d75e0f1752fcae755de3373c420e790b55558cd3ffbf3a7bc1f7baa5bdb76a34fb4927b12e5ec1b465b952c4d368018761942d01725a50573a5ca6984f5b34b3e10e64f5bef82b8737f73c39fcc2786372514f81d876a8e4b0d76facaee943af4c3c1d3ebbd8e6e6dc918c3d031a65b6cb83c96ee4e9d0560576391286b14b897539826743187f560caa5d7f965d20b6df874261b6da081ca73daef43a721dbdaf42f20b5028e88f2ab50baae319955c2ddc0a6f3324f5ef51cb752659b1d3a1d55042e7088a697363c16e79254c28d06bcd346b87634ad4c43c7ff5186ac6e3970e11133cb45f8a89dd7867a4c60f68af6d30721b31f0662f4c8dfcdd3292cefd40e069546db39445391b30aff6c274c042bea0e7cd91d3d80b63040ec93bb9066d4ac0e83408b45c2b104bc28f9d0269d8bb5d1099985eccdb303bdc2d262b35eb4ad56f4a487f207fcf1e495c57c39f6a6087bc2b5a35af4bce6825e589c0401a2f9ab74311eb53d6b85db2a50c8f2725cd62e2098a472b6da85ab8d6023447931e1fbeb3d73b8319f53df0b86b1ee3f6f683ef909cea6d34f34f4d2d0bf0b14c632d8901c1265248c60fe2449bccfc61705e995179e058202006e020a9fb00b5c7c85b53f66b2d765fff5fd8ab3c7805f6c755f4517b38cbf9dab21ad49b4b24e09a8cad5a150bfba0b2d882af6bf96970c54ce14a0b64aef77c8734cf413811811263491f0b77311651c025767f0dea6fea072832428ae59420a38b9442b20e1e31398cb21f37e273248ebe41da988c6e5ff7d367a73e1df59adebd0ecbeec0c088109afa4b4b3f49922855e10b8159debd1e3860612612877adc6cb6efc12952503823b6f42bdd2d3a9ea7a7bcdf3510746e2b126eacb0bd6743ded891011994bde38b2389cf307ea0e711e053c301d24f2bb968080ce450cb1a560b38df9ee7888f25f52c329362102c2ac855a3bffbcd0bad8e914491ca6453fe4320262935b3b8a0a1d7f7c980f1898c423b326528916f3eaa639563a1bb326eaacb95c5922edd58d62f6d68e44702645247b399bb346cbe8b115987e1cca3b46aa4bac880e8eb0e60739321ae4a058f82e4f8941198e911d4ca074e9301ec5d645b6df94195ec5f2cd53cd040f9b105c5a0d3defc36e0197125b7f16027f052d4b6e0c227d3ad3ca377d2ad9793454351ac7c8ee6149d51c377aa711e315ff476fbcad33b0a398e0a13d2a1e8f52da92bc358470eae84badbb265c7339613f8189edbf8633b5c1e7491eea3344538e67effe6d5382b3955f667669570d3c6962bd443ea19db3df98e7f02280a47eb9179c1d287e3bedcbe4bb98fa9197ac187688873ea72d7e5ee40b02b99585bf154ad89bfa76848a3539effaad8f165b63392230f11aa655ddbdc0552ae79b05549b2f32c0d1a2ff3778bdf7cbc66297feb02dca7874ab471b031772d358ac0f21cf6676897d6f5c9290c96af1718e479e1341393133386f245c55556c6aaa571e2e5258619440df58f1a8840b06aa9a3d378035f7e234d7d94eb6041a46fbdfe94b787b0b0e83f80b83148dfa902c9c2f71cce1fda178d611951774612a28280beb4ae7ac819c157d0116a46c422383b04839255d1a3d1ec60d5bf97e36e33441f03335fd9c6b1fe0ee9727eb15c20627f20687c01d33c649bb990a7dcbb48d09a88e1a35ea87184ec54221af4635370fe591b1df61e38acd7d7cfae363205526160157fef3769ecf4072bae8e7998190b25cb31890ea8f32ee7e5dbf54eabc3463e7e57268ade5132b4dbff52f03d9a123e3299c7f4a4b01207fd5c1165256a6ec53c0e36eeefc850e31499a67883a5b434ff87b5087fb2fa266067e24941210743c32b6bc03666e1cf418a9f4819c0d2a3532896c1667c730ed5f94e62d203249498e5215820b9a9fbfa5cabc909373f12a8ef42cd7568452c362397326e12a4c5fe13a84068875eac49c1a038e6f23dd499dabf9039d0807e40fbafe984a59306b4769885184ee87cfbb3f7d9792c69ff523da45606e1b0324c3ff1049f23f9c36e75128fad54c45c1b8ab800fed0c6ce429497d2d4b00638a13d7f3923846fed402b946f788327ac228734c3b179baa8a9e729aee4f74ca276d9f56c5f7b5995dfdf35cefab16c0d077a906e311d111cf26a3d71b7ee9964ee60ad70a13c48b620a867ed2302059a60d88395e3a2871d58f3f3c2bd696a52ead9f639be0b0f1a413ec7c57a5dbe9404d3bc515d4545aed87f471f751e1ba1ad0242744115b3e9f8850b9e2ff13b5a0e8efc3c616077e7d95977e53ef486e5868d896ba16078dd341d4d209e265b9aa3f20ecc4f8c3f1af9c203b735b70874e1bad5219afe69de58b23e11d92dbaac741105abb05dc1a746c02d5d0093b4edbb1dbb9ff24fa15f9712665ae58fb55a39fb7cc225967771dae114b8e2f4d1b3b08685a0950d214a0be840ac9786e1a477c1541b92c4cb6fe20efebfeccc90cba1ef68c5bf9747f51e1f1f00e21de93d89e7d6f601903f2a566e60100395f1b682387d3f14667bd185b7aaa6c58c17d8edd91568093df75ff831ca2fe742219ecaca50362fd872d621a0bdfa9e6ceadf07d2962828a9030693e5ebf10873126adf7c0b11a5b7dda38c383ad4a5d9e3e063ce94ac79c15504366bbaa354f77cb98a5db02d4271e5c2a77ca2fd17d24484df3da51816d95c205a282a73b149575bee43691c8d6dfbc7d54057c17b7fdd80ea82e9f8a11276a0fd90416b9250c96e18e272ee617d4bb393662d5548a53bdb6d3396ddc644faad038d71c35c99292b36924ba37d89a0647b3386f2b0e5e22dbbfd7c237f35ef87937179fc804e7d8f15505931281e54c222976e2180693d11019d9ebca5f416c3717f8248b985cdb1ff00d66bde382b15584c96bc1d19bf086a9513a2af54da68609bc4dfa0491a57c67a73a915024704157b767dab5c2b4af6563206485dc40c99de42fdf94e95bca324acfac77b8e0f48aa93be71d9a56d634863511d7c8e7935eac5dc56a14fdb0db9d1e733db613e36d7ac739737ea8e15b328fab1ff1bfe08b20e2c45f252c5dffab28f3249293d732639a1be44b87a08cd7981f2f6d4dcc84865ea5f1fa9d7116c7e76363e445dfe7ee5f59f0b1febfe53777f0577cf4bbe1aa626bd66c1bee7394d0f06f15d7990b9d60138ad0349e80786128e7f537b5d51efaf6d8f029e671110d9bc6d47c2d056d9ea3e0c179c28bdadc65c1475d07081fd3a86ad3474313caca8296cc2a27bf24e5c11bae86648e2fa8b39a9ba469fe789dcfba543aaaaa6d647ef2a78ce01e0e8f9d6cec6e80debd59bbf1ded24fd47829327ea73f6c5e2b71e8980882a50299a00188ed0d88d4dd8b88a7966ba1f69d78d1dcf8a9f037a4bbddd0a07b7d06896098de101d693d76fee6f25634ae51e64b6c07aa27dcf31b88e3076d4f4f52a3fd0a4ce83008a25ddcb3956429dcde048508445e39f07e81c05483d8bb2df36fcf162c7a247a9031ce11dd5e20f0c2ebc54a92c90597ef5d63eb31bccada0bcfb4c53365f77d4b2ef70cdab1933b3fc341b8097db1a5d0caf94ef8a79867e6eec249e0888e7a53024979b7cbf13c2833c4fe6f2202cb855b4c5da963120b7a2a9b8452d072a090224811d2127d621d941dec1d5fbebf3e291e8d11e0cf4ebb38923da27f73e825fe1642782719f0e6c25fea8735addbd8367ea89a06e52030f81340ab8545b16633185fd3213b286a326392b5fe2d6c823f901b8fe8cbd510254ba405c823d9eef1a4e1937e2c39af99b52cb38f2633d98d3a68641e72d58b1be90990c054af6602c25e8925d831d8887a0dc633185a62b6da3bc1f1a2bffc4d4d20e247d48956e855c727d4599cbdef76d60e41787edfc5f10dee48fdc3772e780af8f641056474432067cb1ae9ba688e9c03a852dc92811d8bc03824535217530bb5754aa55d13f8080267287b3774d32ab8c9c3a69456aa2d716d83ee45c076ea8224e3ed45af5fdbe54f6b5327fb3c644131e1e3f9baedb672e7fc45fac73a6dca58f9a63d5e150bd4c0276937adb138e9b0f0795dd7b1dbd8dc6cbca86bebd632417be9b09d8eff0a2ded57d9136bee61523f5aa104894c3c0f186bce3f2ddccde7a70236e2ef26fc8a12e5c990be4ac1c0d5f5b3f2d8dc933dfca0873b5134fa61d5153ea53103a2c56232f904c9233307935ac545f21b0ab28ecbec62c1751cad06f4b000063b004099aca957614cdb2387eb575ff1f6acad2c92af86ce730c051db4fc392563e93eae44178694ddaeec3248dd8d6f791c41985900447f7f4f35545d55f67bd63d87877fb114d80956916cd96abf26ae3fbe0d2055b9029db3546bb9de2deaaeed1d8595909e38af2ff1a222d2b5ccb613fac39742d7a7d662524861644761ab91839664245747a3973bc1f7314d8450da492dc4f7a6f3cba4caf8f7af18efddb5e50717282c780292249b64073eb20f3a48b84024decbd27568ac6cd99a439ed9e0f1f12111ac33c06e106a8463b5c9942f67b292ea250492b964ac09f400e358ce137a23205b3ce812f187c9e879c69fb59574ebcf383073ee9bcf6011fbc107a5e7f5a71bf40386ed91887e7c20b78d687009cdd1bd54b1607820eda97325cdb257f7ce1f5b044c37008c6c0e10ce2c555a6f2b3a769c4c6e6e20d54de3e4550ef8c4447407bdcc23f53df5be03eb8b4046225230906d8be0391287a08fd2a0f0fb246485cf367a94b90c199140d4ebbca13106ba1f57cc92b2dcfaf70c9a8cffbed72afd535e51612a18646d2d8f3a624b97f7f6896fe011743259c364ad92d718e23e3b24b3dcd8ef269c33a3d14e9dee6e76491563d370d90c6b896894c05598ed8abf4c9b35071bde0f35aa9b4047c915bf739b50d0f15050caaa314606b04ea5cf6a3f8cb7eb1729fb167fe268fb35b179a67fdd052d78754a30ea9af9603e69cda3978109b0ce974568ef72877dc8fad6e2d6a9b3a0633078cc39b5211c2f7a5cf25682d7af436bf30ddcaaa484447b9da8e4b997e585b0e7082e67da622e47efc9bdfef2de347056fa76b45549c008b6bf17817e06711bc6cbbb37471cc41b871356","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"32eb4d6b296cc44c36e673cf43051aea"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
